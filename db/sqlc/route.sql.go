// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: route.sql

package db

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
)

const createRoute = `-- name: CreateRoute :one
INSERT INTO routes (
    id,
    driver_id,
    vehicle_id,
    origin_address,
    origin_lat,
    origin_lng,
    destination_address,
    destination_lat,
    destination_lng,
    estimated_distance_km,
    estimated_duration_min,
    status
)
VALUES (
    $1, $2, $3,
    $4, $5, $6,
    $7, $8, $9,
    $10, $11, $12
)
RETURNING id, driver_id, vehicle_id, origin_lat, origin_lng, destination_lat, destination_lng, origin_address, destination_address, estimated_distance_km, estimated_duration_min, actual_duration_min, status, created_at, updated_at
`

type CreateRouteParams struct {
	ID                   uuid.UUID       `json:"id"`
	DriverID             uuid.UUID       `json:"driver_id"`
	VehicleID            uuid.UUID       `json:"vehicle_id"`
	OriginAddress        sql.NullString  `json:"origin_address"`
	OriginLat            float64         `json:"origin_lat"`
	OriginLng            float64         `json:"origin_lng"`
	DestinationAddress   sql.NullString  `json:"destination_address"`
	DestinationLat       float64         `json:"destination_lat"`
	DestinationLng       float64         `json:"destination_lng"`
	EstimatedDistanceKm  sql.NullFloat64 `json:"estimated_distance_km"`
	EstimatedDurationMin sql.NullFloat64 `json:"estimated_duration_min"`
	Status               string          `json:"status"`
}

func (q *Queries) CreateRoute(ctx context.Context, arg CreateRouteParams) (Route, error) {
	row := q.db.QueryRowContext(ctx, createRoute,
		arg.ID,
		arg.DriverID,
		arg.VehicleID,
		arg.OriginAddress,
		arg.OriginLat,
		arg.OriginLng,
		arg.DestinationAddress,
		arg.DestinationLat,
		arg.DestinationLng,
		arg.EstimatedDistanceKm,
		arg.EstimatedDurationMin,
		arg.Status,
	)
	var i Route
	err := row.Scan(
		&i.ID,
		&i.DriverID,
		&i.VehicleID,
		&i.OriginLat,
		&i.OriginLng,
		&i.DestinationLat,
		&i.DestinationLng,
		&i.OriginAddress,
		&i.DestinationAddress,
		&i.EstimatedDistanceKm,
		&i.EstimatedDurationMin,
		&i.ActualDurationMin,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteRoute = `-- name: DeleteRoute :exec


DELETE FROM routes WHERE id = $1
`

// when the route is completed
func (q *Queries) DeleteRoute(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deleteRoute, id)
	return err
}

const getRouteByID = `-- name: GetRouteByID :one
SELECT id, driver_id, vehicle_id, origin_lat, origin_lng, destination_lat, destination_lng, origin_address, destination_address, estimated_distance_km, estimated_duration_min, actual_duration_min, status, created_at, updated_at FROM routes WHERE id = $1
`

func (q *Queries) GetRouteByID(ctx context.Context, id uuid.UUID) (Route, error) {
	row := q.db.QueryRowContext(ctx, getRouteByID, id)
	var i Route
	err := row.Scan(
		&i.ID,
		&i.DriverID,
		&i.VehicleID,
		&i.OriginLat,
		&i.OriginLng,
		&i.DestinationLat,
		&i.DestinationLng,
		&i.OriginAddress,
		&i.DestinationAddress,
		&i.EstimatedDistanceKm,
		&i.EstimatedDurationMin,
		&i.ActualDurationMin,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getRoutesByDriverID = `-- name: GetRoutesByDriverID :many
SELECT id, driver_id, vehicle_id, origin_lat, origin_lng, destination_lat, destination_lng, origin_address, destination_address, estimated_distance_km, estimated_duration_min, actual_duration_min, status, created_at, updated_at FROM routes
WHERE driver_id = $1
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type GetRoutesByDriverIDParams struct {
	DriverID uuid.UUID `json:"driver_id"`
	Limit    int32     `json:"limit"`
	Offset   int32     `json:"offset"`
}

func (q *Queries) GetRoutesByDriverID(ctx context.Context, arg GetRoutesByDriverIDParams) ([]Route, error) {
	rows, err := q.db.QueryContext(ctx, getRoutesByDriverID, arg.DriverID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Route{}
	for rows.Next() {
		var i Route
		if err := rows.Scan(
			&i.ID,
			&i.DriverID,
			&i.VehicleID,
			&i.OriginLat,
			&i.OriginLng,
			&i.DestinationLat,
			&i.DestinationLng,
			&i.OriginAddress,
			&i.DestinationAddress,
			&i.EstimatedDistanceKm,
			&i.EstimatedDurationMin,
			&i.ActualDurationMin,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRoutes = `-- name: ListRoutes :many
SELECT id, driver_id, vehicle_id, origin_lat, origin_lng, destination_lat, destination_lng, origin_address, destination_address, estimated_distance_km, estimated_duration_min, actual_duration_min, status, created_at, updated_at FROM routes
WHERE status = $1
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type ListRoutesParams struct {
	Status string `json:"status"`
	Limit  int32  `json:"limit"`
	Offset int32  `json:"offset"`
}

func (q *Queries) ListRoutes(ctx context.Context, arg ListRoutesParams) ([]Route, error) {
	rows, err := q.db.QueryContext(ctx, listRoutes, arg.Status, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Route{}
	for rows.Next() {
		var i Route
		if err := rows.Scan(
			&i.ID,
			&i.DriverID,
			&i.VehicleID,
			&i.OriginLat,
			&i.OriginLng,
			&i.DestinationLat,
			&i.DestinationLng,
			&i.OriginAddress,
			&i.DestinationAddress,
			&i.EstimatedDistanceKm,
			&i.EstimatedDurationMin,
			&i.ActualDurationMin,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateRouteStatus = `-- name: UpdateRouteStatus :one
UPDATE routes
SET status = COALESCE(NULLIF($2, ''), status),
    updated_at = NOW()
WHERE id = $1
RETURNING id, driver_id, vehicle_id, origin_lat, origin_lng, destination_lat, destination_lng, origin_address, destination_address, estimated_distance_km, estimated_duration_min, actual_duration_min, status, created_at, updated_at
`

type UpdateRouteStatusParams struct {
	ID      uuid.UUID   `json:"id"`
	Column2 interface{} `json:"column_2"`
}

func (q *Queries) UpdateRouteStatus(ctx context.Context, arg UpdateRouteStatusParams) (Route, error) {
	row := q.db.QueryRowContext(ctx, updateRouteStatus, arg.ID, arg.Column2)
	var i Route
	err := row.Scan(
		&i.ID,
		&i.DriverID,
		&i.VehicleID,
		&i.OriginLat,
		&i.OriginLng,
		&i.DestinationLat,
		&i.DestinationLng,
		&i.OriginAddress,
		&i.DestinationAddress,
		&i.EstimatedDistanceKm,
		&i.EstimatedDurationMin,
		&i.ActualDurationMin,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateRouteActualDuration = `-- name: updateRouteActualDuration :one
UPDATE routes
SET actual_duration_min = $2,
    updated_at = NOW()
WHERE id = $1
RETURNING id, driver_id, vehicle_id, origin_lat, origin_lng, destination_lat, destination_lng, origin_address, destination_address, estimated_distance_km, estimated_duration_min, actual_duration_min, status, created_at, updated_at
`

type updateRouteActualDurationParams struct {
	ID                uuid.UUID       `json:"id"`
	ActualDurationMin sql.NullFloat64 `json:"actual_duration_min"`
}

func (q *Queries) updateRouteActualDuration(ctx context.Context, arg updateRouteActualDurationParams) (Route, error) {
	row := q.db.QueryRowContext(ctx, updateRouteActualDuration, arg.ID, arg.ActualDurationMin)
	var i Route
	err := row.Scan(
		&i.ID,
		&i.DriverID,
		&i.VehicleID,
		&i.OriginLat,
		&i.OriginLng,
		&i.DestinationLat,
		&i.DestinationLng,
		&i.OriginAddress,
		&i.DestinationAddress,
		&i.EstimatedDistanceKm,
		&i.EstimatedDurationMin,
		&i.ActualDurationMin,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
